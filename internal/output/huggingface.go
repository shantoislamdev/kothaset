package output

import (
	"encoding/json"
	"os"
	"path/filepath"
	"sync"
	"time"

	"github.com/shantoislamdev/kothaset/internal/schema"
)

// HuggingFaceWriter writes samples in HuggingFace datasets format
type HuggingFaceWriter struct {
	schema     schema.Schema
	path       string
	samples    []*schema.Sample
	splitRatio float64 // Train/test split (0 = no split)
	mu         sync.Mutex
}

// NewHuggingFaceWriter creates a new HuggingFace format writer
func NewHuggingFaceWriter(sch schema.Schema) *HuggingFaceWriter {
	return &HuggingFaceWriter{
		schema:     sch,
		samples:    make([]*schema.Sample, 0, 1000),
		splitRatio: 0, // Default: no split
	}
}

func (w *HuggingFaceWriter) Format() string { return "hf" }

func (w *HuggingFaceWriter) Open(path string) error {
	w.path = path
	// Create directory structure
	if err := os.MkdirAll(path, 0755); err != nil {
		return err
	}
	return nil
}

func (w *HuggingFaceWriter) OpenAppend(path string) error {
	// HuggingFace writer buffers samples and writes on Close
	// Just set the path - the checkpoint system tracks progress
	w.path = path
	// Ensure directory exists
	if err := os.MkdirAll(path, 0755); err != nil {
		return err
	}
	return nil
}

func (w *HuggingFaceWriter) Write(sample *schema.Sample) error {
	w.mu.Lock()
	defer w.mu.Unlock()
	w.samples = append(w.samples, sample)
	return nil
}

func (w *HuggingFaceWriter) Flush() error {
	return nil
}

func (w *HuggingFaceWriter) Close() error {
	w.mu.Lock()
	defer w.mu.Unlock()

	if len(w.samples) == 0 {
		return nil
	}

	// Write dataset_info.json
	if err := w.writeDatasetInfo(); err != nil {
		return err
	}

	// Write data files
	if w.splitRatio > 0 && w.splitRatio < 1 {
		return w.writeWithSplit()
	}
	return w.writeTrainOnly()
}

func (w *HuggingFaceWriter) writeDatasetInfo() error {
	info := map[string]any{
		"description":  "Dataset generated by KothaSet CLI",
		"citation":     "",
		"homepage":     "https://kothaset.pages.dev",
		"license":      "",
		"features":     w.buildFeatures(),
		"builder_name": "kothaset",
		"config_name":  "default",
		"version": map[string]int{
			"version_str": 1,
			"major":       1,
			"minor":       0,
			"patch":       0,
		},
		"splits":        w.buildSplits(),
		"download_size": 0,
		"dataset_size":  0,
		"size_in_bytes": 0,
	}

	infoPath := filepath.Join(w.path, "dataset_info.json")
	file, err := os.Create(infoPath)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(info)
}

func (w *HuggingFaceWriter) buildFeatures() map[string]any {
	features := make(map[string]any)
	for _, field := range w.schema.Fields() {
		features[field.Name] = map[string]string{
			"dtype": "string",
			"_type": "Value",
		}
	}
	return features
}

func (w *HuggingFaceWriter) buildSplits() map[string]any {
	splits := make(map[string]any)
	if w.splitRatio > 0 && w.splitRatio < 1 {
		trainSize := int(float64(len(w.samples)) * (1 - w.splitRatio))
		splits["train"] = map[string]any{
			"name":         "train",
			"num_bytes":    0,
			"num_examples": trainSize,
		}
		splits["test"] = map[string]any{
			"name":         "test",
			"num_bytes":    0,
			"num_examples": len(w.samples) - trainSize,
		}
	} else {
		splits["train"] = map[string]any{
			"name":         "train",
			"num_bytes":    0,
			"num_examples": len(w.samples),
		}
	}
	return splits
}

func (w *HuggingFaceWriter) writeTrainOnly() error {
	return w.writeSplit("train", w.samples)
}

func (w *HuggingFaceWriter) writeWithSplit() error {
	splitIdx := int(float64(len(w.samples)) * (1 - w.splitRatio))

	if err := w.writeSplit("train", w.samples[:splitIdx]); err != nil {
		return err
	}
	return w.writeSplit("test", w.samples[splitIdx:])
}

func (w *HuggingFaceWriter) writeSplit(name string, samples []*schema.Sample) error {
	// Create split directory
	splitDir := filepath.Join(w.path, name)
	if err := os.MkdirAll(splitDir, 0755); err != nil {
		return err
	}

	// Write as JSONL (compatible with HF datasets)
	dataPath := filepath.Join(splitDir, "data-00000-of-00001.jsonl")
	file, err := os.Create(dataPath)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	for _, sample := range samples {
		if err := encoder.Encode(sample.Fields); err != nil {
			return err
		}
	}

	// Write state.json
	statePath := filepath.Join(w.path, "state.json")
	state := map[string]any{
		"_data_files": []map[string]string{
			{"filename": filepath.Join(name, "data-00000-of-00001.jsonl")},
		},
		"_fingerprint": time.Now().Format("20060102150405"),
		"_format_type": "json",
	}
	stateFile, err := os.Create(statePath)
	if err != nil {
		return err
	}
	defer stateFile.Close()

	stateEncoder := json.NewEncoder(stateFile)
	stateEncoder.SetIndent("", "  ")
	return stateEncoder.Encode(state)
}

// SetSplitRatio sets the train/test split ratio (e.g., 0.2 = 20% test)
func (w *HuggingFaceWriter) SetSplitRatio(ratio float64) {
	w.splitRatio = ratio
}
